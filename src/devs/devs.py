# -*- coding: utf-8 -*-__author__ = 'Moore.Huang'import socketimport sslimport timeimport httplibimport jsonimport threadingimport urllibimport sysfrom PyQt4 import QtGui, QtCorefrom src.devs.devs_ui import Ui_JDSmartCloud_Devsfrom src.http_server import HTTPServertry:    _fromUtf8 = QtCore.QString.fromUtf8except AttributeError:    def _fromUtf8(s):        return sclass SmartCloudDevice(QtGui.QWidget):    def __init__(self,                 product_id='41',                 address=('apismart.jd.com', httplib.HTTPS_PORT),                 jd_key='iKvyNBTcB9eTDB1oqgBuxFtVI9iJB1jgBcVqHZXNGCpN19Hp',                 parent=None):        QtGui.QWidget.__init__(self, parent)        self.ui = Ui_JDSmartCloud_Devs()        self.ui.setupUi(self)        self.ui.pbClearLog.clicked.connect(self.__clear_log)        self.ui.pbControlDev.clicked.connect(self.__dev_status_slot)        self.ui.pbDevActive.clicked.connect(self.__active_https_slot)        self.ui.pbUploadData.clicked.connect(self.__upload_data_slot)        self.product_id = product_id        self.host, self.port = address        self.jd_key = jd_key        self.access_key = None        self.feed_id = None        self.event_server_address = None        self.event_server_socket = None        self.switch_status = 0        self.__recv_event_fd = threading.Thread(name='recv event', target=self.__recv_event)        self.__send_heartbeat_fd = threading.Thread(name='heartbeat', target=self.__send_heartbeat)        self.__recv_event_fd.setDaemon(True)        self.__send_heartbeat_fd.setDaemon(True)        self.http_server = HTTPServer(address)    def __append_ptelog(self, string):        self.ui.pteLog.appendPlainText(string)    def active_dev(self, device_id):        headers_req = self.http_server.get_headers(self.host, self.jd_key)        body_req = {HTTPServer.B_DEVICE_ID: device_id, HTTPServer.B_PRODUCT_ID: self.product_id}        rc = self.http_server.run_https_req('POST', '/v1/device/activate', headers_req, body_req)        if rc is False:            return False        _res = self.http_server.get_response()        body_rsp = _res.read()        body_rsp_obj = json.loads(body_rsp)        body_rsp_str = json.dumps(body_rsp_obj, indent=4)        print 'len => [%d],\t data => \r\n%s' % (len(body_rsp), body_rsp_str)        self.__append_ptelog(body_rsp_str)        try:            key = 'code'            if int(body_rsp_obj[key]) != 200:                print "body_rsp_obj[%s] is not '200'" % key                self.http_server.disconnect_https()                return False        except KeyError:            print 'Can not find the key[%s]!' % key            self.http_server.disconnect_https()            return False        try:            self.access_key = body_rsp_obj['data']['access_key']            self.feed_id = body_rsp_obj['data']['feed_id']            self.ui.leFeedID.setText(self.feed_id)            self.ui.leAccessKey.setText(self.access_key)            host, port = body_rsp_obj['data']['server_ip'][0].split(':')            self.event_server_address = (str(host), int(port))        except KeyError:            print 'Can not find the key!'            self.http_server.disconnect_https()            return False        print 'access_key => [%s],\t feed_id => [%s],\t server_ip => [%s]'\              % (self.access_key, self.feed_id, self.event_server_address)        self.ui.pbControlDev.setEnabled(True)        self.ui.pbUploadData.setEnabled(True)        self.http_server.disconnect_https()        return True    def upload_data(self, temp):        time_str = self.http_server.get_time_str()        headers_req = self.http_server.get_headers(self.host, self.access_key)        body_req = {'streams': [            {'stream_id': 'temp',             'datapoints': [{'at': time_str, 'value': str(temp)}]},            {'stream_id': 'switch',             'datapoints': [{'at': time_str, 'value': str(self.switch_status)}]}        ]}        print 'body => %s' % json.dumps(body_req)        rc = self.http_server.run_https_req('POST', '/v1/feeds/%s' % self.feed_id, headers_req, body_req)        if rc is False:            return False        _res = self.http_server.get_response()        body_rsp = _res.read()        print 'len => [%d],\t body => %s' % (len(body_rsp), body_rsp)        body_json_rsp = json.loads(body_rsp)        try:            if int(body_json_rsp[HTTPServer.H_CODE_KEY]) != 200:                print "body_json_rsp[%s] is not '200'" % HTTPServer.H_CODE_KEY                self.http_server.disconnect_https()                return False        except KeyError:            print 'Can not find the key[%s]!' % HTTPServer.H_CODE_KEY            self.http_server.disconnect_https()            return False        self.http_server.disconnect_https()        return True    def __active_https_slot(self):        device_id = str(self.ui.leDevNum.text())        if device_id == '':            self.__append_ptelog(u'请输入设备序号，以便激活此设备！')            return        print 'device id => [%s]' % device_id        _res = self.active_dev(device_id)        self.active_event_server_socket()        self.__enable_event_server()        self.__append_ptelog(u'激活设备:\t%s' % str(_res))        self.ui.pbDevActive.setEnabled(False)        self.ui.leDevNum.setReadOnly(True)        self.ui.lStatusDisp.setPixmap(QtGui.QPixmap(_fromUtf8(":/ui/resources/green_light.png")))    def __dev_status_slot(self, status):        if status:            s = 'on'            self.switch_status = 1            self.ui.pbControlDev.setChecked(True)        else:            s = 'off'            self.switch_status = 0            self.ui.pbControlDev.setChecked(False)        icon = QtGui.QIcon()        icon.addPixmap(QtGui.QPixmap(_fromUtf8(":/ui/resources/switch_%s.png" % s)),                       QtGui.QIcon.Normal, QtGui.QIcon.Off)        self.ui.pbControlDev.setIcon(icon)        self.ui.pbControlDev.setIconSize(QtCore.QSize(48, 48))    def active_event_server_socket(self):        self.event_server_socket = ssl.wrap_socket(socket.socket(), ca_certs='keyfile.pem')        self.event_server_socket.connect(self.event_server_address)        print u'连接成功:\t%s' % str(self.event_server_address)    def close_event_server_socket(self):        if self.event_server_socket is not None:            self.event_server_socket.close()            self.event_server_socket = None        else:            print 'the event_server_socket is None!'    def __enable_event_server(self):        self.__recv_event_fd.start()        self.__send_heartbeat_fd.start()    def __send_heartbeat(self):        print 'start send heartbeat!'        hb = {'code': 101, 'device': {'feed_id': str(self.feed_id), 'accees_key': self.access_key}}        hb_json_str = json.dumps(hb)        while True:            try:                self.event_server_socket.sendall(hb_json_str+'\r\n')            except httplib.CannotSendRequest:                self.__append_ptelog(u'心跳发送失败！重新连接...')                self.close_event_server_socket()                self.active_event_server_socket()                continue            time.sleep(30)    def __recv_event(self):        print 'start recv event!'        control_rsp = {'code': 102, 'result': 0,                       'control_resp': None,                       'device': {                                    'feed_id': self.feed_id,                                    'accees_key': self.access_key                       }}        while True:            try:                recv = self.event_server_socket.makefile().readline()            except:                self.__append_ptelog(u'SSL Socket断线重连！')                self.close_event_server_socket()                self.active_event_server_socket()                continue            if recv == '':                continue            # print 'recv data =>', recv            recv_quote = urllib.unquote(recv).replace('+"', '"')            print 'recv data decode =>', recv_quote            try:                recv_json_obj = json.loads(recv_quote)            except ValueError:                print 'the package is not a JSON pack! [%s]' % recv_quote                continue            try:                if int(recv_json_obj['code']) == 1002:                    control_rsp['control_resp'] = self.__process_cmd(recv_json_obj['control'])                    # control_rsp['device']['feed_id'] = self.feed_id                    # control_rsp['device']['accees_key'] = self.access_key                else:                    print 'heartbeat rsp => %s' % recv_quote                    continue            except KeyError:                print 'Can not find the key!'                continue            control_rsp_str = json.dumps(control_rsp, indent=4)            print control_rsp_str            self.__append_ptelog(control_rsp_str)            self.__append_ptelog(u'设备状态:\t%d' % self.switch_status)            self.event_server_socket.sendall(json.dumps(control_rsp)+'\r\n')    def __process_cmd(self, cmd):        try:            for item in cmd:                if item['stream_id'] == 'switch':                    self.switch_status = int(item['current_value'])                    self.__dev_status_slot(bool(self.switch_status))        except KeyError:            print 'Can not find the key!'            return {"info": "failed", 'switch': str(self.switch_status)}        return {"info": "success", 'switch': str(self.switch_status)}    def __upload_data_slot(self):        temp = str(self.ui.leTempDisp.text())        if temp is None:            self.__append_ptelog(u'Err: 温度数据为空！')            return        if temp.isdigit():            res = self.upload_data(temp)            self.__append_ptelog(u'上传数据:\t%s' % str(res))        else:            self.__append_ptelog(u'Err: 温度数据不为数字！')    def __clear_log(self):        self.ui.pteLog.clear()app = QtGui.QApplication(sys.argv)sca = SmartCloudDevice()sca.show()sys.exit(app.exec_())